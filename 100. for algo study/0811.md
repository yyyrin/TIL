# 버블 정렬

![버블정렬 이미지](https://t1.daumcdn.net/cfile/tistory/275F9A4A545095BD01)
- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
<br><br><br>

## 📍 아이디어
1. 배열의 i번째 인덱스와 i+1번째 인덱스의 키를 비교
2. i번째 인덱스의 키가 더 크다면 자리를 상호 교환(swap)
3. 위 과정을 반복수행
<br><br><br>

## 📍 시간 복잡도
- **O(N^2)**
- 각 순회마다 비교 대상이 하나씩 줄어들기 때문에, 비교하는 데에 소모되는 시간
<br>

  ```
  (N-1) + (N-2) + ... + 2 + 1 = N * (N-1) / 2
  ```
- 비교 과정에서 총 **O(N^2)** 만큼의 시간을 소모
- 최악의 경우, 비교할 때마다 교환 발생 -> **O(N^2)**
<br><br><br>

## 📍 특징
- 장점
  - 구현이 간단
  - 데이터를 하나씩 비교하기 때문에 정밀한 비교가 가능
  <br><br>
- 단점
  - 데이터를 전부 비교해야 하므로 시간 효율이 좋지 X
<br><br><br>

## 📍 구현
```PYTHON
arr = [4, 6, 1, 7, 2, 9, 3]

n = len(arr)

for i in range(n-1, 0, -1):   # 비교하는 숫자 개수
	for j in range(i):
		if arr[j] > arr[j+1]:
			arr[j], arr[j+1] = arr[j+1], arr[j]
```
<br><br>

---
# 카운팅 정렬


---

# 선택정렬

![선택정렬 이미지](https://velog.velcdn.com/images/ss-hj/post/7ece2654-6af6-4d23-8efa-f44916298509/image.png)
- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
<br><br><br>

## 📍 아이디어
1. 주어진 리스트 중 최소값 선택
2. 그 값을 리스트의 맨 앞에 위치한 값과 교환
3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정
<br><br><br>

## 📍 시간 복잡도
- **O(N)**
- 루프문을 통해 배열의 모든 값에 접근해야 한다.
- 각 루프마다 맨 앞에 위치한 값를 제외한 값들 중 최소값을 찾고, 이를 맨 앞에 위치한 값과 교환(swap)해주어야 한다.
<br><br><br>

## 📍 특징
- 장점
  - 구현이 간단하다.
  - 데이터를 하나씩 비교하기 때문에 정밀한 비교가 가능하다.
  - 비교 횟수에 비해 교환 횟수가 적다.
  <br><br>
- 단점
  - 시간이 오래 걸린다.
  - 정렬된 상태에서 데이터가 추가되었을 때 정렬 효율이 좋지 않다.
<br><br><br>

## 📍 구현
```PYTHON
arr = [4, 6, 1, 7, 2, 9, 3]

n = len(arr)

for i in range(n-1, 0, -1):
	min_idx = i    # 임의로 최소값 지정

	for j in range(i):
		if arr[j] < arr[min_idx]:
			min_idx = j
	
	arr[i], arr[min_idx] = arr[min_idx], arr[i]
```
<br><br>

---
