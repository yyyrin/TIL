# 버블 정렬

![버블정렬 이미지](https://t1.daumcdn.net/cfile/tistory/275F9A4A545095BD01)
- 인접한 두 개의 원소를 비교하며 자리를 계속 교환하는 방식
<br><br><br>

## 📍 아이디어
1. 배열의 i번째 인덱스와 i+1번째 인덱스의 키를 비교
2. i번째 인덱스의 키가 더 크다면 자리를 상호 교환(swap)
3. 위 과정을 반복수행
<br><br><br>

## 📍 시간 복잡도
- **O(N^2)**
- 각 순회마다 비교 대상이 하나씩 줄어들기 때문에, 비교하는 데에 소모되는 시간
<br>

  ```
  (N-1) + (N-2) + ... + 2 + 1 = N * (N-1) / 2
  ```
- 비교 과정에서 총 **O(N^2)** 만큼의 시간을 소모
- 최악의 경우, 비교할 때마다 교환 발생 -> **O(N^2)**
<br><br><br>

## 📍 특징
- 장점
  - 구현이 간단
  - 데이터를 하나씩 비교하기 때문에 정밀한 비교가 가능
  <br><br>
- 단점
  - 데이터를 전부 비교해야 하므로 시간 효율이 좋지 X
<br><br><br>

## 📍 구현
```PYTHON
arr = [4, 6, 1, 7, 2, 9, 3]

n = len(arr)

for i in range(n-1, 0, -1):   # 비교하는 숫자 개수
	for j in range(i):
		if arr[j] > arr[j+1]:
			arr[j], arr[j+1] = arr[j+1], arr[j]
```
<br><br>

---
# 카운팅 정렬

![카운팅정렬 이미지](https://cdn.programiz.com/cdn/farfuture/tcfjQdeYwL_jETOCPZxNjIXbysRrb7MaG6PwO2MzHnM/mtime:1582112622/sites/tutorial2program/files/Counting-sort-4_1.png)
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여 선형 시간에 정렬하는 방식
<br><br><br>

## 📍 아이디어
1. 가장 작은 데이터부터 가장 큰 데이터까지의 범위가 모두 담길 수 있는 리스트 생성
2. 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가
3. 증가된 리스트에서 0인 값을 제외하고, 인덱스를 인덱스 값만큼 출력
<br><br><br>

## 📍 시간 복잡도
- **O(n + k)**
- n: 리스트 길이
- k: 정수의 최대값
- k가 단순히 상수로 취급되어 생략되지 않고 남아있는 이유 -> 그만큼 k에 따라 수행시간에 영향을 미치기 때문
- k < n 이라면 정렬의 수행시간 -> O(n)
- k가 무한대로 크다면 정렬의 수행시간도 무한대
<br><br><br>

## 📍 특징
- 장점
  - 선형 시간에 정렬이 가능
  - 정수로 표현 가능
  - 값 사이의 차이가 크지 않을 경우 사용하기 좋음
  <br><br>
- 단점
  - 제한 사항이 많음
  - 정수나, 정수로 표현할 수 있는 자료에 대해서만 적용 가능
  - 각 항목의 발생 횟수를 기록해야 하기 때문에 정수로 인덱스 되는 카운트들의 배열을 사용
  - 카운트를 위한 충분한 공간을 할당하기 위해서는 집합 내의 가장 큰 정수를 알아야 함
<br><br><br>

## 📍 구현
```PYTHON
arr = [4, 7, 9, 1, 3, 5, 2, 3, 4]

count = [0] * (max(arr) + 1)
# 원소의 최대값까지 인덱스로 사용하기 위해

for num in arr:
    count[num] += 1
# [0, 1, 1, 2, 2, 1, 0, 1, 0, 1]

for i in range(1, len(count)):
    count[i] += count[i-1]
# [0, 1, 2, 4, 6, 7, 7, 8, 8, 9]
# arr에 담긴 원소를 바로 정렬된 위치로 삽입하기 위한 사전작업

result = [0] * (len(arr))  # arr의 원소를 정렬된 위치에 삽입

for num in arr:
    idx = count[num]
    result[idx - 1] = num  # 인덱스가 0부터 시작하기 때문
    count[num] -= 1

print(result)

# [1, 2, 3, 3, 4, 4, 5, 7, 9]
```
<br><br>

---

# 선택정렬

![선택정렬 이미지](https://velog.velcdn.com/images/ss-hj/post/7ece2654-6af6-4d23-8efa-f44916298509/image.png)
- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식
<br><br><br>

## 📍 아이디어
1. 주어진 리스트 중 최소값 선택
2. 그 값을 리스트의 맨 앞에 위치한 값과 교환
3. 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정
<br><br><br>

## 📍 시간 복잡도
- **O(N)**
- 루프문을 통해 배열의 모든 값에 접근해야 한다.
- 각 루프마다 맨 앞에 위치한 값를 제외한 값들 중 최소값을 찾고, 이를 맨 앞에 위치한 값과 교환(swap)해주어야 한다.
<br><br><br>

## 📍 특징
- 장점
  - 구현이 간단하다.
  - 데이터를 하나씩 비교하기 때문에 정밀한 비교가 가능하다.
  - 비교 횟수에 비해 교환 횟수가 적다.
  <br><br>
- 단점
  - 시간이 오래 걸린다.
  - 정렬된 상태에서 데이터가 추가되었을 때 정렬 효율이 좋지 않다.
<br><br><br>

## 📍 구현
```PYTHON
arr = [4, 6, 1, 7, 2, 9, 3]

n = len(arr)

for i in range(n-1, 0, -1):
	min_idx = i    # 임의로 최소값 지정

	for j in range(i):
		if arr[j] < arr[min_idx]:
			min_idx = j
	
	arr[i], arr[min_idx] = arr[min_idx], arr[i]
```
<br><br>

---
