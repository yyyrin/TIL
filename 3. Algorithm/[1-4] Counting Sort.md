# 카운팅 정렬 (Counting Sort)

1. 카운팅 정렬
    - 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘
    - 제한사항
        - 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능
            - 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문
        - 카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.
    - 시간 복잡도
        - O(n+k) : n은 리스트 길이, k는 정수의 최대값
    
2. 카운팅 정렬 과정
    - [0, 4, 1, 3, 1, 2, 4, 1]을 카운팅 정렬하는 과정
        - Data에서 각 항목들의 발생 회수를 세고, 정수 항목들로 직접 인덱스 되는 카운트 배열 counts에 저장한다.
        - 정렬된 집합에서 각 항목의 앞에 위치할 항목의 개수를 반영하기 위해 counts의 원소를 조정한다.
        - count[1]을 감소시키고 Temp에 1을 삽입한다.
        - count[4]를 감소시키고 temp에 4를 삽입한다.
        - count[2]를 감소시키고 temp에 2를 삽입한다.
        - count[1]를 감소시키고 temp에 1를 삽입한다.
        - count[3]를 감소시키고 temp에 3를 삽입한다.
        - count[1]를 감소시키고 temp에 1를 삽입한다.
        - count[4]를 감소시키고 temp에 4를 삽입한다.
        - count[0]를 감소시키고 temp에 0를 삽입한다.
        - Temp 업데이트 완료하고 정렬 작업을 종료한다.
    - 코드로 구현
        
        ```python
        def Counting_Sort(A, B, k):
        # A [] -- 입력 배열(1 to k)
        # B [] -- 정럴된 배열
        # C [] -- 카운트 배열
        
            C = [0] * (k+1)
        
            for i in range(0, len(A)):
                C[A[i]]  += 1
        
            for i in range(1, len(C)):
                C[i] += C[i-1]
        
            for i in range(len(B)-1, -1, -1):
                C[A[i]] -= 1
                B[C[A[i]]] = A[i]
        ```
        
    
3. 정렬 알고리즘 특성
    
    
    | 알고리즘 | 평균 수행시간 | 최악 수행시간 | 알고리즘 기법 | 비고 |
    | --- | --- | --- | --- | --- |
    | 버블 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 코딩이 가장 손쉽다. |
    | 카운티 정렬 | O(n+k) | O(n+k) | 비교환 방식 | n이 비교적 작을 때만 가능하다. |
    | 선택 정렬 | O(n^2) | O(n^2) | 비교와 교환 | 교환의 회수가 버블,
    삽입정렬보다 작다. |
    | 퀵 정렬 | O(n log n) | O(n^2) | 분할 정복 | 최악의 경우 O(n^2) 이지만,
    평균적으로는 가장 빠르다. |
    | 삽입 정렬 | O(n^2) | O(n^2) | 비교와 교환 | n의 개수가 작을 때 효과적이다. |
    | 병합 정렬 | O(n log n) | O(n log n) | 분할 정복 | 연결리스트의 경우 가장 효율적인 방식 |

---
